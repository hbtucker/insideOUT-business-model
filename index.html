<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Model Template</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@200;400;600&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #chart {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .slice-label {
            font-size: 9px;
            pointer-events: none;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="chart"></div>

    <script>
        const data = {
            name: "Our Mission",
            children: [
                {
                    name: "Value Proposition",
                    children: [
                        { name: "Product/Service Offering", value: 1 },
                        { name: "Customer Benefits", value: 1 },
                        { name: "Unique Selling Point", value: 1 }
                    ]
                },
                {
                    name: "Customer Segments",
                    children: [
                        { name: "Target Market", value: 1 },
                        { name: "Customer Personas", value: 1 },
                        { name: "Market Size", value: 1 }
                    ]
                },
                {
                    name: "Revenue Streams",
                    children: [
                        { name: "Pricing Model", value: 1 },
                        { name: "Sales Channels", value: 1 },
                        { name: "Revenue Sources", value: 1 }
                    ]
                },
                {
                    name: "Key Resources",
                    children: [
                        { name: "Physical Assets", value: 1 },
                        { name: "Intellectual Property", value: 1 },
                        { name: "Human Resources", value: 1 }
                    ]
                },
                {
                    name: "Key Activities",
                    children: [
                        { name: "Core Operations", value: 1 },
                        { name: "Marketing & Sales", value: 1 },
                        { name: "R&D", value: 1 }
                    ]
                }
            ]
        };

        const width = Math.min(window.innerWidth, window.innerHeight) * 0.8;
        const height = width;
        const radius = width / 8;

        const richerColors = [
            "#FF9AA2", "#A8D8B9", "#8AC6D1", "#FFDAC1", "#c1df90",
            "#B5EAD7", "#C7CEEA", "#F6D5E5", "#FFE5B4", "#D4A5A5"
        ];

        const color = d3.scaleOrdinal()
            .domain(data.children.map(d => d.name))
            .range(richerColors);

        const partition = data => {
            const root = d3.hierarchy(data)
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value);
            return d3.partition()
                .size([2 * Math.PI, root.height + 1])
                (root);
        };

        const root = partition(data);
        root.each(d => d.current = d);

        const svg = d3.select('#chart')
            .append('svg')
            .style('width', '100%')
            .style('height', '100%')
            .attr('viewBox', [-width / 2, -height / 2, width, height])
            .style("font-family", "'Poppins', sans-serif")

        const g = svg.append('g');

        const arc = d3.arc()
            .startAngle(d => d.x0)
            .endAngle(d => d.x1)
            .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
            .padRadius(radius * 1.5)
            .innerRadius(d => d.y0 * radius)
            .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1));

        function arcVisible(d) {
            return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
        }

        function labelVisible(d) {
            return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
        }

        function labelTransform(d) {
            const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
            const y = (d.y0 + d.y1) / 2 * radius;
            const rotation = x - 90;
            const translate = `translate(${y},0)`;
            return `rotate(${rotation}) ${translate} rotate(${-rotation})`;
        }

        let path = g.append('g')
            .selectAll('path')
            .data(root.descendants().slice(1))
            .join('path')
            .attr('fill', d => { while (d.depth > 1) d = d.parent; return color(d.data.name); })
            .attr('fill-opacity', d => arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0)
            .attr('pointer-events', d => arcVisible(d.current) ? 'auto' : 'none')
            .attr('d', d => arc(d.current));

        path.filter(d => d.children)
            .style('cursor', 'pointer')
            .on('click', clicked);

        function applyHoverEffect(selection) {
            selection.on('mouseover', function(event, d) {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('transform', function(d) {
                        const [x, y] = arc.centroid(d.current);
                        const scale = d.current.y0 === 0 ? 1 : 1.04;
                        return `scale(${scale}) translate(${x * 0.01},${y * 0.01})`;
                    })
                    .attr('fill-opacity', 1);
            })
            .on('mouseout', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('transform', 'scale(1) translate(0,0)')
                    .attr('fill-opacity', d => d.children ? 0.6 : 0.4);
            });
        }

        applyHoverEffect(path);

        const format = d3.format(',d');
        path.append('title')
            .text(d => `${d.ancestors().map(d => d.data.name).reverse().join('/')}\n${format(d.value)}`);

        let label = g.append('g')
            .attr('pointer-events', 'none')
            .attr('text-anchor', 'middle')
            .style('user-select', 'none')
            .selectAll('text')
            .data(root.descendants().slice(1))
            .join('text')
            .attr('class', 'slice-label')
            .attr('dy', '0.35em')
            .attr('fill-opacity', d => +labelVisible(d.current))
            .attr('transform', d => labelTransform(d.current))
            .text(d => d.data.name)
            .each(function(d) {
                const node = d3.select(this);
                const words = d.data.name.split(/\s+/);
                let line = [];
                let lineNumber = 0;
                const lineHeight = 1.2;
                const y = 0;
                const x = 0;
                let tspan = node.text(null).append('tspan').attr('x', x).attr('y', y);
                words.forEach(word => {
                    line.push(word);
                    tspan.text(line.join(' '));
                    if (tspan.node().getComputedTextLength() > 30) {
                        line.pop();
                        tspan.text(line.join(' '));
                        line = [word];
                        tspan = node.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + 'em').text(word);
                    }
                });
            });

        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        const parent = g.append('circle')
            .datum(root)
            .attr('r', radius)
            .attr('fill', 'none')
            .attr('pointer-events', 'all')
            .on('click', clicked)
            .on('mouseover', function(event, d) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.html("Click to zoom out")
                    .style("left", (event.pageX) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on('mouseout', function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });

        const centerLabel = g.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '0.35em')
            .attr('font-size', '12px')
            .attr('pointer-events', 'none')
            .text(data.name);

        function clicked(event, p) {
            parent.datum(p.parent || root);

            root.each(d => d.target = {
                x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                y0: Math.max(0, d.y0 - p.depth),
                y1: Math.max(0, d.y1 - p.depth)
            });

            const t = g.transition().duration(750);

            // UPDATE: Remove old paths and labels
            path.remove();
            label.remove();

            // UPDATE: Create new paths and labels
            path = g.append('g')
                .selectAll('path')
                .data(root.descendants().slice(1))
                .join('path')
                .attr('fill', d => { while (d.depth > 1) d = d.parent; return color(d.data.name); })
                .attr('fill-opacity', d => arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0)
                .attr('pointer-events', d => arcVisible(d.target) ? 'auto' : 'none')
                .attr('d', d => arc(d.target));

            path.filter(d => d.children)
                .style('cursor', 'pointer')
                .on('click', clicked);

            applyHoverEffect(path);

            path.append('title')
                .text(d => `${d.ancestors().map(d => d.data.name).reverse().join('/')}\n${format(d.value)}`);

            label = g.append('g')
                .attr('pointer-events', 'none')
                .attr('text-anchor', 'middle')
                .style('user-select', 'none')
                .selectAll('text')
                .data(root.descendants().slice(1))
                .join('text')
                .attr('class', 'slice-label')
                .attr('dy', '0.35em')
                .attr('fill-opacity', d => +labelVisible(d.target))
                .attr('transform', d => labelTransform(d.target))
                .text(d => d.data.name)
                .each(function(d) {
                    const node = d3.select(this);
                    const words = d.data.name.split(/\s+/);
                    let line = [];
                    let lineNumber = 0;
                    const lineHeight = 1.2;
                    const y = 0;
                    const x = 0;
                    let tspan = node.text(null).append('tspan').attr('x', x).attr('y', y);
                    words.forEach(word => {
                        line.push(word);
                        tspan.text(line.join(' '));
                        if (tspan.node().getComputedTextLength() > 30) {
                            line.pop();
                            tspan.text(line.join(' '));
                            line = [word];
                            tspan = node.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + 'em').text(word);
                        }
                    });
                });

            centerLabel.text(p.depth ? p.data.name : data.name);
        }
    </script>
</body>
</html>
